<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess.com Clone - Play Chess Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f0f0f0;
            min-height: 100vh;
            padding: 10px;
        }
        
        /* Header */
        .header {
            background-color: #2c2c3e;
            border-radius: 10px;
            padding: 10px 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo h1 {
            color: #fff;
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        .logo-icon {
            font-size: 28px;
            color: #7fa650;
        }
        
        .user-auth {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .auth-btn {
            background-color: #7fa650;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .auth-btn:hover {
            background-color: #8fb85e;
            transform: translateY(-2px);
        }
        
        .auth-btn.secondary {
            background-color: #444;
        }
        
        .auth-btn.secondary:hover {
            background-color: #555;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .username {
            font-weight: 600;
            color: #7fa650;
        }
        
        /* Main Container */
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Left Panel - Game Board */
        .left-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            background-color: #2c2c3e;
            border-radius: 10px 10px 0 0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .game-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-name {
            font-weight: 600;
        }
        
        .player-rating {
            color: #aaa;
            font-size: 0.9rem;
        }
        
        .player-color {
            width: 25px;
            height: 25px;
            border-radius: 50%;
        }
        
        .white-color {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
        }
        
        .black-color {
            background-color: #333;
            border: 1px solid #666;
        }
        
        .game-controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background-color: #555;
        }
        
        .control-btn.primary {
            background-color: #7fa650;
        }
        
        .control-btn.primary:hover {
            background-color: #8fb85e;
        }
        
        .board-container {
            background-color: #2c2c3e;
            border-radius: 0 0 10px 10px;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 560px;
            height: 560px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            position: relative;
        }
        
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            user-select: none;
        }
        
        .light {
            background-color: #f0d9b5;
        }
        
        .dark {
            background-color: #b58863;
        }
        
        .selected {
            background-color: rgba(103, 155, 255, 0.5) !important;
        }
        
        .valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 5;
        }
        
        .capture-move::after {
            content: '';
            position: absolute;
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            background-color: transparent;
            z-index: 5;
        }
        
        .piece {
            font-size: 48px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            z-index: 10;
            transition: transform 0.2s;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .piece:hover {
            transform: scale(1.05);
        }
        
        .white {
            color: #ffffff;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        .black {
            color: #000000;
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.3);
        }
        
        .coordinates {
            position: absolute;
            color: #666;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
        }
        
        .file-coordinate {
            position: absolute;
            bottom: -20px;
            width: 70px;
            text-align: center;
        }
        
        .rank-coordinate {
            position: absolute;
            left: -20px;
            height: 70px;
            display: flex;
            align-items: center;
        }
        
        /* Right Panel */
        .right-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel {
            background-color: #2c2c3e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .panel-title {
            color: #7fa650;
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title i {
            font-size: 1.3rem;
        }
        
        /* Game Status */
        .game-status {
            text-align: center;
            padding: 15px;
            background-color: rgba(40, 40, 60, 0.7);
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .status-text {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .turn-piece {
            font-size: 32px;
        }
        
        /* Move History */
        .move-history {
            height: 200px;
            overflow-y: auto;
            background-color: rgba(20, 20, 35, 0.7);
            border-radius: 5px;
            padding: 10px;
        }
        
        .move-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .move-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.05);
            font-family: 'Courier New', monospace;
        }
        
        .move-entry:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Game Finder */
        .game-finder {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .finder-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .time-control {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .time-btn {
            padding: 10px;
            background-color: #444;
            color: #ccc;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .time-btn:hover {
            background-color: #555;
        }
        
        .time-btn.active {
            background-color: #7fa650;
            color: white;
        }
        
        .finder-btn {
            background-color: #7fa650;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.2s;
            margin-top: 10px;
        }
        
        .finder-btn:hover {
            background-color: #8fb85e;
            transform: translateY(-2px);
        }
        
        /* Auth Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: #2c2c3e;
            border-radius: 10px;
            width: 400px;
            max-width: 90%;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            color: #7fa650;
            font-size: 1.5rem;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #aaa;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .close-btn:hover {
            color: white;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            background-color: #3a3a4e;
            border: 1px solid #555;
            border-radius: 5px;
            color: white;
            font-size: 1rem;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #7fa650;
        }
        
        .form-btn {
            width: 100%;
            padding: 12px;
            background-color: #7fa650;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.2s;
        }
        
        .form-btn:hover {
            background-color: #8fb85e;
        }
        
        .form-footer {
            text-align: center;
            margin-top: 20px;
            color: #aaa;
        }
        
        .form-footer a {
            color: #7fa650;
            cursor: pointer;
            text-decoration: none;
        }
        
        .form-footer a:hover {
            text-decoration: underline;
        }
        
        .error-message {
            color: #ff6b6b;
            font-size: 0.9rem;
            margin-top: 5px;
            display: none;
        }
        
        /* Game List */
        .game-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .game-item {
            background-color: rgba(40, 40, 60, 0.7);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .game-item:hover {
            background-color: rgba(50, 50, 70, 0.9);
            transform: translateX(5px);
        }
        
        .game-item-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .game-item-players {
            color: #aaa;
            font-size: 0.9rem;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            margin-top: 20px;
            color: #888;
            font-size: 0.9rem;
            padding: 10px;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .board {
                width: 480px;
                height: 480px;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }
            
            .board {
                width: 400px;
                height: 400px;
            }
            
            .piece {
                font-size: 40px;
            }
        }
        
        @media (max-width: 500px) {
            .board {
                width: 320px;
                height: 320px;
            }
            
            .piece {
                font-size: 32px;
            }
            
            .game-header {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-chess logo-icon"></i>
            <h1>ChessMaster</h1>
        </div>
        <div class="user-auth">
            <div id="user-info" style="display: none;">
                <div class="user-info">
                    <span class="username" id="display-username">Guest</span>
                    <button class="auth-btn secondary" id="logout-btn">Logout</button>
                </div>
            </div>
            <div id="login-buttons">
                <button class="auth-btn" id="login-btn">Login</button>
                <button class="auth-btn secondary" id="signup-btn">Sign Up</button>
            </div>
        </div>
    </div>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Panel - Game Board -->
        <div class="left-panel">
            <div class="game-header">
                <div class="game-info">
                    <div class="player-info">
                        <div class="player-color white-color"></div>
                        <div>
                            <div class="player-name" id="white-player">You (White)</div>
                            <div class="player-rating">1500</div>
                        </div>
                    </div>
                    <div style="font-size: 24px; color: #7fa650;">VS</div>
                    <div class="player-info">
                        <div class="player-color black-color"></div>
                        <div>
                            <div class="player-name" id="black-player">Computer (Black)</div>
                            <div class="player-rating">1500</div>
                        </div>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="control-btn" id="undo-btn" title="Undo move">
                        <i class="fas fa-undo"></i>
                    </button>
                    <button class="control-btn primary" id="new-game-btn">
                        <i class="fas fa-plus-circle"></i> New Game
                    </button>
                    <button class="control-btn" id="resign-btn">
                        <i class="fas fa-flag"></i> Resign
                    </button>
                </div>
            </div>
            <div class="board-container">
                <div class="board" id="chessboard">
                    <!-- Chessboard will be generated by JavaScript -->
                    <!-- File coordinates will be added by JS -->
                    <!-- Rank coordinates will be added by JS -->
                </div>
            </div>
        </div>
        
        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Game Status -->
            <div class="panel">
                <div class="panel-title">
                    <i class="fas fa-info-circle"></i> Game Status
                </div>
                <div class="game-status">
                    <div class="status-text" id="game-status">White to move</div>
                    <div class="turn-indicator">
                        <div class="piece white" id="turn-indicator">♔</div>
                        <span id="turn-text">White's turn</span>
                    </div>
                </div>
            </div>
            
            <!-- Move History -->
            <div class="panel">
                <div class="panel-title">
                    <i class="fas fa-history"></i> Move History
                </div>
                <div class="move-history">
                    <div class="move-list" id="move-list">
                        <!-- Move history will be added here -->
                    </div>
                </div>
            </div>
            
            <!-- Game Finder -->
            <div class="panel">
                <div class="panel-title">
                    <i class="fas fa-search"></i> Find a Game
                </div>
                <div class="game-finder">
                    <div class="finder-options">
                        <div>Time Control</div>
                        <div class="time-control">
                            <button class="time-btn active" data-time="10">10 min</button>
                            <button class="time-btn" data-time="5">5 min</button>
                            <button class="time-btn" data-time="3">3 min</button>
                            <button class="time-btn" data-time="1">1 min</button>
                            <button class="time-btn" data-time="30">30 sec</button>
                            <button class="time-btn" data-time="15">15 sec</button>
                        </div>
                    </div>
                    <button class="finder-btn" id="play-computer-btn">
                        <i class="fas fa-robot"></i> Play Computer
                    </button>
                    <button class="finder-btn" id="find-player-btn">
                        <i class="fas fa-users"></i> Find Player
                    </button>
                </div>
            </div>
            
            <!-- Available Games -->
            <div class="panel">
                <div class="panel-title">
                    <i class="fas fa-gamepad"></i> Available Games
                </div>
                <div class="game-list" id="game-list">
                    <!-- Game list will be populated by JavaScript -->
                    <div class="game-item">
                        <div class="game-item-header">
                            <span>Quick Game</span>
                            <span>5+0</span>
                        </div>
                        <div class="game-item-players">Player1 (1500) vs Player2 (1520)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Login Modal -->
    <div class="modal" id="login-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Login</div>
                <button class="close-btn" id="close-login">&times;</button>
            </div>
            <form id="login-form">
                <div class="form-group">
                    <label for="login-username">Username</label>
                    <input type="text" id="login-username" required>
                    <div class="error-message" id="login-username-error"></div>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required>
                    <div class="error-message" id="login-password-error"></div>
                </div>
                <button type="submit" class="form-btn">Login</button>
            </form>
            <div class="form-footer">
                Don't have an account? <a id="switch-to-signup">Sign up</a>
            </div>
        </div>
    </div>
    
    <!-- Signup Modal -->
    <div class="modal" id="signup-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Create Account</div>
                <button class="close-btn" id="close-signup">&times;</button>
            </div>
            <form id="signup-form">
                <div class="form-group">
                    <label for="signup-username">Username</label>
                    <input type="text" id="signup-username" required>
                    <div class="error-message" id="signup-username-error"></div>
                </div>
                <div class="form-group">
                    <label for="signup-email">Email</label>
                    <input type="email" id="signup-email" required>
                    <div class="error-message" id="signup-email-error"></div>
                </div>
                <div class="form-group">
                    <label for="signup-password">Password</label>
                    <input type="password" id="signup-password" required>
                    <div class="error-message" id="signup-password-error"></div>
                </div>
                <div class="form-group">
                    <label for="signup-confirm-password">Confirm Password</label>
                    <input type="password" id="signup-confirm-password" required>
                    <div class="error-message" id="signup-confirm-error"></div>
                </div>
                <button type="submit" class="form-btn">Create Account</button>
            </form>
            <div class="form-footer">
                Already have an account? <a id="switch-to-login">Login</a>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <div class="footer">
        <p>ChessMaster © 2023 | Play chess online with players around the world</p>
    </div>

    <script>
        // Game state and logic
        document.addEventListener('DOMContentLoaded', function() {
            // Game state variables
            let boardState = [];
            let selectedPiece = null;
            let validMoves = [];
            let currentPlayer = 'white';
            let gameOver = false;
            let moveHistory = [];
            let castlingRights = { white: { kingSide: true, queenSide: true }, black: { kingSide: true, queenSide: true } };
            let enPassantTarget = null;
            let playerColor = 'white'; // Color player is playing
            let gameMode = 'computer'; // computer, player, or find
            let gameTime = 600; // 10 minutes in seconds
            
            // User state
            let currentUser = null;
            let users = JSON.parse(localStorage.getItem('chess_users') || '{}');
            let availableGames = [];
            
            // DOM elements
            const chessboard = document.getElementById('chessboard');
            const gameStatus = document.getElementById('game-status');
            const turnIndicator = document.getElementById('turn-indicator');
            const turnText = document.getElementById('turn-text');
            const moveList = document.getElementById('move-list');
            const whitePlayer = document.getElementById('white-player');
            const blackPlayer = document.getElementById('black-player');
            const newGameBtn = document.getElementById('new-game-btn');
            const undoBtn = document.getElementById('undo-btn');
            const resignBtn = document.getElementById('resign-btn');
            const playComputerBtn = document.getElementById('play-computer-btn');
            const findPlayerBtn = document.getElementById('find-player-btn');
            
            // Auth elements
            const userInfo = document.getElementById('user-info');
            const loginButtons = document.getElementById('login-buttons');
            const displayUsername = document.getElementById('display-username');
            const loginBtn = document.getElementById('login-btn');
            const signupBtn = document.getElementById('signup-btn');
            const logoutBtn = document.getElementById('logout-btn');
            
            // Modal elements
            const loginModal = document.getElementById('login-modal');
            const signupModal = document.getElementById('signup-modal');
            const closeLogin = document.getElementById('close-login');
            const closeSignup = document.getElementById('close-signup');
            const switchToSignup = document.getElementById('switch-to-signup');
            const switchToLogin = document.getElementById('switch-to-login');
            const loginForm = document.getElementById('login-form');
            const signupForm = document.getElementById('signup-form');
            
            // Time control buttons
            const timeBtns = document.querySelectorAll('.time-btn');
            
            // Piece Unicode characters
            const pieceUnicode = {
                'king': { 'white': '♔', 'black': '♚' },
                'queen': { 'white': '♕', 'black': '♛' },
                'rook': { 'white': '♖', 'black': '♜' },
                'bishop': { 'white': '♗', 'black': '♝' },
                'knight': { 'white': '♘', 'black': '♞' },
                'pawn': { 'white': '♙', 'black': '♟' }
            };
            
            // Initialize the game
            function initGame() {
                createBoard();
                setupPieces();
                renderBoard();
                updateGameStatus();
                setupEventListeners();
                checkUserStatus();
                updateAvailableGames();
                
                // Set default time control
                timeBtns[0].classList.add('active');
            }
            
            // Create the chessboard with coordinates
            function createBoard() {
                chessboard.innerHTML = '';
                
                // Create squares
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        // Add file and rank for debugging
                        const file = String.fromCharCode(97 + col);
                        const rank = 8 - row;
                        square.dataset.coordinate = `${file}${rank}`;
                        
                        chessboard.appendChild(square);
                    }
                }
                
                // Add file coordinates (a-h)
                for (let col = 0; col < 8; col++) {
                    const fileCoord = document.createElement('div');
                    fileCoord.className = 'coordinates file-coordinate';
                    fileCoord.textContent = String.fromCharCode(97 + col);
                    fileCoord.style.left = `${col * 70 + 25}px`;
                    chessboard.appendChild(fileCoord);
                }
                
                // Add rank coordinates (1-8)
                for (let row = 0; row < 8; row++) {
                    const rankCoord = document.createElement('div');
                    rankCoord.className = 'coordinates rank-coordinate';
                    rankCoord.textContent = 8 - row;
                    rankCoord.style.top = `${row * 70 + 25}px`;
                    chessboard.appendChild(rankCoord);
                }
            }
            
            // Set up the initial piece positions
            function setupPieces() {
                // Initialize empty board
                boardState = Array(8).fill().map(() => Array(8).fill(null));
                
                // Set up pawns
                for (let col = 0; col < 8; col++) {
                    boardState[6][col] = { type: 'pawn', color: 'white', hasMoved: false };
                    boardState[1][col] = { type: 'pawn', color: 'black', hasMoved: false };
                }
                
                // Set up other pieces
                const pieceOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                for (let col = 0; col < 8; col++) {
                    boardState[7][col] = { type: pieceOrder[col], color: 'white', hasMoved: false };
                    boardState[0][col] = { type: pieceOrder[col], color: 'black', hasMoved: false };
                }
                
                // Reset castling rights
                castlingRights = { white: { kingSide: true, queenSide: true }, black: { kingSide: true, queenSide: true } };
                enPassantTarget = null;
                moveHistory = [];
                updateMoveHistory();
            }
            
            // Render the board based on boardState
            function renderBoard() {
                // Clear any existing selection and valid move indicators
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'valid-move', 'capture-move');
                });
                
                // Render pieces
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                        
                        // Clear the square
                        square.innerHTML = '';
                        
                        // Add piece if present
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.color}`;
                            pieceElement.textContent = pieceUnicode[piece.type][piece.color];
                            pieceElement.dataset.piece = piece.type;
                            pieceElement.dataset.color = piece.color;
                            square.appendChild(pieceElement);
                        }
                    }
                }
                
                // Highlight selected piece
                if (selectedPiece) {
                    const { row, col } = selectedPiece.position;
                    const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                    square.classList.add('selected');
                    
                    // Highlight valid moves
                    validMoves.forEach(move => {
                        const moveSquare = document.querySelector(`.square[data-row="${move.row}"][data-col="${move.col}"]`);
                        if (boardState[move.row][move.col]) {
                            moveSquare.classList.add('capture-move');
                        } else {
                            moveSquare.classList.add('valid-move');
                        }
                    });
                }
            }
            
            // Calculate valid moves for a piece (including castling and en passant)
            function calculateValidMoves(piece, position) {
                const { row, col } = position;
                const moves = [];
                
                // Helper function to add a move if it's valid
                const addMove = (newRow, newCol, isCapture = false) => {
                    // Check if move is within board bounds
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        // Check if the square is empty or has an opponent's piece
                        const targetPiece = boardState[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== piece.color) {
                            moves.push({ row: newRow, col: newCol, isCapture: !!targetPiece });
                            
                            // For sliding pieces, continue in the same direction if square is empty
                            if (['rook', 'bishop', 'queen'].includes(piece.type) && !targetPiece) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                
                // Different move patterns for each piece type
                switch (piece.type) {
                    case 'pawn':
                        const direction = piece.color === 'white' ? -1 : 1;
                        const startRow = piece.color === 'white' ? 6 : 1;
                        
                        // Move forward one square
                        if (boardState[row + direction][col] === null) {
                            addMove(row + direction, col);
                            
                            // Move forward two squares from starting position
                            if (row === startRow && boardState[row + 2 * direction][col] === null) {
                                addMove(row + 2 * direction, col);
                            }
                        }
                        
                        // Capture moves
                        if (col > 0 && boardState[row + direction][col - 1] && 
                            boardState[row + direction][col - 1].color !== piece.color) {
                            addMove(row + direction, col - 1, true);
                        }
                        
                        if (col < 7 && boardState[row + direction][col + 1] && 
                            boardState[row + direction][col + 1].color !== piece.color) {
                            addMove(row + direction, col + 1, true);
                        }
                        
                        // En passant
                        if (enPassantTarget) {
                            const targetRow = piece.color === 'white' ? 3 : 4;
                            if (row === targetRow) {
                                if (enPassantTarget.col === col - 1) {
                                    addMove(row + direction, col - 1, true);
                                }
                                if (enPassantTarget.col === col + 1) {
                                    addMove(row + direction, col + 1, true);
                                }
                            }
                        }
                        break;
                        
                    case 'knight':
                        // Knight moves in L-shape
                        const knightMoves = [
                            [row - 2, col - 1], [row - 2, col + 1],
                            [row - 1, col - 2], [row - 1, col + 2],
                            [row + 1, col - 2], [row + 1, col + 2],
                            [row + 2, col - 1], [row + 2, col + 1]
                        ];
                        
                        knightMoves.forEach(([newRow, newCol]) => {
                            const targetPiece = boardState[newRow] && boardState[newRow][newCol];
                            addMove(newRow, newCol, !!targetPiece);
                        });
                        break;
                        
                    case 'bishop':
                        // Bishop moves diagonally
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row - i, col - i)) break;
                            if (boardState[row - i][col - i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row - i, col + i)) break;
                            if (boardState[row - i][col + i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + i, col - i)) break;
                            if (boardState[row + i][col - i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + i, col + i)) break;
                            if (boardState[row + i][col + i]) break;
                        }
                        break;
                        
                    case 'rook':
                        // Rook moves horizontally and vertically
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row - i, col)) break;
                            if (boardState[row - i][col]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + i, col)) break;
                            if (boardState[row + i][col]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row, col - i)) break;
                            if (boardState[row][col - i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row, col + i)) break;
                            if (boardState[row][col + i]) break;
                        }
                        break;
                        
                    case 'queen':
                        // Queen combines rook and bishop moves
                        // Bishop-like moves (diagonals)
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row - i, col - i)) break;
                            if (boardState[row - i][col - i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row - i, col + i)) break;
                            if (boardState[row - i][col + i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + i, col - i)) break;
                            if (boardState[row + i][col - i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + i, col + i)) break;
                            if (boardState[row + i][col + i]) break;
                        }
                        
                        // Rook-like moves (horizontal/vertical)
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row - i, col)) break;
                            if (boardState[row - i][col]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row + i, col)) break;
                            if (boardState[row + i][col]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row, col - i)) break;
                            if (boardState[row][col - i]) break;
                        }
                        
                        for (let i = 1; i < 8; i++) {
                            if (!addMove(row, col + i)) break;
                            if (boardState[row][col + i]) break;
                        }
                        break;
                        
                    case 'king':
                        // King moves one square in any direction
                        const kingMoves = [
                            [row - 1, col - 1], [row - 1, col], [row - 1, col + 1],
                            [row, col - 1], [row, col + 1],
                            [row + 1, col - 1], [row + 1, col], [row + 1, col + 1]
                        ];
                        
                        kingMoves.forEach(([newRow, newCol]) => {
                            const targetPiece = boardState[newRow] && boardState[newRow][newCol];
                            addMove(newRow, newCol, !!targetPiece);
                        });
                        
                        // Castling moves
                        if (!piece.hasMoved) {
                            // King-side castling
                            if (castlingRights[piece.color].kingSide) {
                                if (!boardState[row][5] && !boardState[row][6]) {
                                    if (!isSquareAttacked(row, col, piece.color === 'white' ? 'black' : 'white') &&
                                        !isSquareAttacked(row, 5, piece.color === 'white' ? 'black' : 'white') &&
                                        !isSquareAttacked(row, 6, piece.color === 'white' ? 'black' : 'white')) {
                                        moves.push({ row: row, col: 6, isCastle: true, rookFrom: { row, col: 7 }, rookTo: { row, col: 5 } });
                                    }
                                }
                            }
                            
                            // Queen-side castling
                            if (castlingRights[piece.color].queenSide) {
                                if (!boardState[row][1] && !boardState[row][2] && !boardState[row][3]) {
                                    if (!isSquareAttacked(row, col, piece.color === 'white' ? 'black' : 'white') &&
                                        !isSquareAttacked(row, 2, piece.color === 'white' ? 'black' : 'white') &&
                                        !isSquareAttacked(row, 3, piece.color === 'white' ? 'black' : 'white')) {
                                        moves.push({ row: row, col: 2, isCastle: true, rookFrom: { row, col: 0 }, rookTo: { row, col: 3 } });
                                    }
                                }
                            }
                        }
                        break;
                }
                
                // Filter out moves that would leave king in check
                return moves.filter(move => {
                    // Simulate the move
                    const originalPiece = boardState[row][col];
                    const targetPiece = boardState[move.row][move.col];
                    
                    // Make the move
                    boardState[move.row][move.col] = originalPiece;
                    boardState[row][col] = null;
                    
                    // Handle castling
                    if (move.isCastle) {
                        const rook = boardState[move.rookFrom.row][move.rookFrom.col];
                        boardState[move.rookTo.row][move.rookTo.col] = rook;
                        boardState[move.rookFrom.row][move.rookFrom.col] = null;
                    }
                    
                    // Handle en passant
                    let enPassantPiece = null;
                    if (originalPiece.type === 'pawn' && move.col !== col && !targetPiece) {
                        // This is an en passant capture
                        enPassantPiece = boardState[row][move.col];
                        boardState[row][move.col] = null;
                    }
                    
                    // Check if king is in check
                    const kingPosition = findKing(originalPiece.color);
                    const isInCheck = kingPosition && isSquareAttacked(kingPosition.row, kingPosition.col, originalPiece.color === 'white' ? 'black' : 'white');
                    
                    // Undo the move
                    boardState[row][col] = originalPiece;
                    boardState[move.row][move.col] = targetPiece;
                    
                    // Undo castling
                    if (move.isCastle) {
                        const rook = boardState[move.rookTo.row][move.rookTo.col];
                        boardState[move.rookFrom.row][move.rookFrom.col] = rook;
                        boardState[move.rookTo.row][move.rookTo.col] = null;
                    }
                    
                    // Restore en passant piece
                    if (enPassantPiece) {
                        boardState[row][move.col] = enPassantPiece;
                    }
                    
                    return !isInCheck;
                });
            }
            
            // Find the king of a given color
            function findKing(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            return { row, col };
                        }
                    }
                }
                return null;
            }
            
            // Check if a square is attacked by any piece of the given color
            function isSquareAttacked(targetRow, targetCol, attackingColor) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && piece.color === attackingColor) {
                            const moves = calculateValidMoves(piece, { row, col });
                            if (moves.some(move => move.row === targetRow && move.col === targetCol)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // Handle square click
            function handleSquareClick(row, col) {
                if (gameOver) return;
                
                // If it's computer's turn in computer mode, ignore player clicks
                if (gameMode === 'computer' && currentPlayer === 'black') return;
                
                const clickedPiece = boardState[row][col];
                
                // If a piece is already selected
                if (selectedPiece) {
                    // Check if the clicked square is a valid move for the selected piece
                    const isValidMove = validMoves.find(move => move.row === row && move.col === col);
                    
                    if (isValidMove) {
                        // Move the piece
                        movePiece(selectedPiece.position, { row, col }, isValidMove);
                        selectedPiece = null;
                        validMoves = [];
                        
                        // Switch turn
                        currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                        updateGameStatus();
                        renderBoard();
                        
                        // If playing against computer and it's computer's turn
                        if (gameMode === 'computer' && currentPlayer === 'black') {
                            setTimeout(computerMove, 800);
                        }
                        return;
                    }
                    
                    // If clicking on another piece of the same color, select that piece
                    if (clickedPiece && clickedPiece.color === currentPlayer) {
                        selectPiece(row, col, clickedPiece);
                        return;
                    }
                    
                    // Otherwise, deselect the piece
                    selectedPiece = null;
                    validMoves = [];
                }
                
                // If clicking on an empty square or opponent's piece without a selected piece
                if (!clickedPiece || clickedPiece.color !== currentPlayer) {
                    renderBoard();
                    return;
                }
                
                // Select the clicked piece
                if (clickedPiece.color === currentPlayer) {
                    selectPiece(row, col, clickedPiece);
                }
            }
            
            // Select a piece
            function selectPiece(row, col, piece) {
                selectedPiece = { position: { row, col }, piece };
                validMoves = calculateValidMoves(piece, { row, col });
                renderBoard();
            }
            
            // Move a piece from start to end position
            function movePiece(start, end, moveInfo) {
                const piece = boardState[start.row][start.col];
                const targetPiece = boardState[end.row][end.col];
                
                // Record the move
                const startFile = String.fromCharCode(97 + start.col);
                const startRank = 8 - start.row;
                const endFile = String.fromCharCode(97 + end.col);
                const endRank = 8 - end.row;
                
                let moveNotation = '';
                let pieceSymbol = piece.type === 'pawn' ? '' : piece.type.charAt(0).toUpperCase();
                
                // Handle castling
                if (moveInfo.isCastle) {
                    if (end.col === 6) {
                        moveNotation = 'O-O'; // King-side castling
                    } else {
                        moveNotation = 'O-O-O'; // Queen-side castling
                    }
                } else {
                    // Regular move notation
                    if (targetPiece) {
                        moveNotation = `${pieceSymbol}${pieceSymbol ? 'x' : startFile + 'x'}${endFile}${endRank}`;
                    } else {
                        moveNotation = `${pieceSymbol}${endFile}${endRank}`;
                    }
                }
                
                moveHistory.push({
                    player: piece.color,
                    from: { ...start },
                    to: { ...end },
                    piece: piece.type,
                    notation: moveNotation,
                    isCastle: moveInfo.isCastle,
                    isCapture: !!targetPiece
                });
                
                // Update move history display
                updateMoveHistory();
                
                // Update castling rights if king or rook moves
                if (piece.type === 'king') {
                    castlingRights[piece.color].kingSide = false;
                    castlingRights[piece.color].queenSide = false;
                    piece.hasMoved = true;
                }
                
                if (piece.type === 'rook') {
                    if (start.col === 0) { // Queen-side rook
                        castlingRights[piece.color].queenSide = false;
                    } else if (start.col === 7) { // King-side rook
                        castlingRights[piece.color].kingSide = false;
                    }
                    piece.hasMoved = true;
                }
                
                // Handle castling
                if (moveInfo.isCastle) {
                    // Move the rook
                    const rook = boardState[moveInfo.rookFrom.row][moveInfo.rookFrom.col];
                    boardState[moveInfo.rookTo.row][moveInfo.rookTo.col] = rook;
                    boardState[moveInfo.rookFrom.row][moveInfo.rookFrom.col] = null;
                    rook.hasMoved = true;
                }
                
                // Handle en passant
                if (piece.type === 'pawn' && end.col !== start.col && !targetPiece) {
                    // This is an en passant capture
                    const capturedPawnRow = start.row;
                    const capturedPawnCol = end.col;
                    boardState[capturedPawnRow][capturedPawnCol] = null;
                }
                
                // Set en passant target if pawn moves two squares
                if (piece.type === 'pawn' && Math.abs(end.row - start.row) === 2) {
                    enPassantTarget = { row: start.row + (end.row > start.row ? 1 : -1), col: start.col };
                } else {
                    enPassantTarget = null;
                }
                
                // Move the piece
                boardState[end.row][end.col] = piece;
                boardState[start.row][start.col] = null;
                piece.hasMoved = true;
                
                // Check for pawn promotion
                if (piece.type === 'pawn' && (end.row === 0 || end.row === 7)) {
                    promotePawn(end.row, end.col, piece.color);
                }
                
                // Check for game over conditions
                checkGameStatus();
            }
            
            // Promote a pawn to a queen
            function promotePawn(row, col, color) {
                boardState[row][col] = { type: 'queen', color: color, hasMoved: true };
                renderBoard();
            }
            
            // Computer makes a move
            function computerMove() {
                if (gameOver || currentPlayer !== 'black') return;
                
                // Get all possible moves for black pieces
                const possibleMoves = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && piece.color === 'black') {
                            const moves = calculateValidMoves(piece, { row, col });
                            
                            moves.forEach(move => {
                                possibleMoves.push({
                                    from: { row, col },
                                    to: move,
                                    piece: piece.type
                                });
                            });
                        }
                    }
                }
                
                // If no moves available, it's stalemate or checkmate
                if (possibleMoves.length === 0) {
                    gameOver = true;
                    const isCheck = isKingInCheck('black');
                    if (isCheck) {
                        gameStatus.textContent = 'Checkmate! White wins!';
                    } else {
                        gameStatus.textContent = 'Stalemate! Game drawn.';
                    }
                    return;
                }
                
                // Select a move (simple AI)
                // Prefer captures, center control, and checks
                const scoredMoves = possibleMoves.map(move => {
                    let score = 0;
                    const targetPiece = boardState[move.to.row][move.to.col];
                    
                    // Prefer captures
                    if (targetPiece) {
                        const pieceValues = { pawn: 1, knight: 3, bishop: 3, rook: 5, queen: 9, king: 0 };
                        score += pieceValues[targetPiece.type] * 10;
                    }
                    
                    // Prefer center control
                    const centerDistance = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
                    score += (14 - centerDistance) * 0.5;
                    
                    // Prefer moves that give check
                    // Simulate the move and check if it gives check
                    const originalPiece = boardState[move.from.row][move.from.col];
                    const originalTarget = boardState[move.to.row][move.to.col];
                    
                    boardState[move.to.row][move.to.col] = originalPiece;
                    boardState[move.from.row][move.from.col] = null;
                    
                    if (isKingInCheck('white')) {
                        score += 5;
                    }
                    
                    // Undo the move
                    boardState[move.from.row][move.from.col] = originalPiece;
                    boardState[move.to.row][move.to.col] = originalTarget;
                    
                    return { move, score };
                });
                
                // Sort by score and pick one of the top moves
                scoredMoves.sort((a, b) => b.score - a.score);
                const topMoves = scoredMoves.slice(0, Math.max(3, Math.floor(scoredMoves.length / 3)));
                const selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)].move;
                
                // Execute the selected move
                const piece = boardState[selectedMove.from.row][selectedMove.from.col];
                const validMovesForPiece = calculateValidMoves(piece, selectedMove.from);
                const moveInfo = validMovesForPiece.find(m => m.row === selectedMove.to.row && m.col === selectedMove.to.col);
                
                if (moveInfo) {
                    movePiece(selectedMove.from, selectedMove.to, moveInfo);
                    
                    // Switch back to player's turn
                    currentPlayer = 'white';
                    updateGameStatus();
                    renderBoard();
                }
            }
            
            // Check if king is in check
            function isKingInCheck(color) {
                const kingPosition = findKing(color);
                if (!kingPosition) return false;
                
                const opponentColor = color === 'white' ? 'black' : 'white';
                return isSquareAttacked(kingPosition.row, kingPosition.col, opponentColor);
            }
            
            // Check game status
            function checkGameStatus() {
                // Check if current player has any valid moves
                let hasValidMoves = false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && piece.color === currentPlayer) {
                            const moves = calculateValidMoves(piece, { row, col });
                            if (moves.length > 0) {
                                hasValidMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasValidMoves) break;
                }
                
                if (!hasValidMoves) {
                    gameOver = true;
                    if (isKingInCheck(currentPlayer)) {
                        const winner = currentPlayer === 'white' ? 'Black' : 'White';
                        gameStatus.textContent = `Checkmate! ${winner} wins!`;
                    } else {
                        gameStatus.textContent = 'Stalemate! Game drawn.';
                    }
                }
            }
            
            // Update game status display
            function updateGameStatus() {
                if (gameOver) return;
                
                if (currentPlayer === 'white') {
                    gameStatus.textContent = 'White to move';
                    turnText.textContent = 'White\'s turn';
                    turnIndicator.className = 'piece white';
                    turnIndicator.textContent = pieceUnicode['king']['white'];
                } else {
                    gameStatus.textContent = 'Black to move';
                    turnText.textContent = 'Black\'s turn';
                    turnIndicator.className = 'piece black';
                    turnIndicator.textContent = pieceUnicode['king']['black'];
                }
                
                // Highlight if king is in check
                if (isKingInCheck(currentPlayer)) {
                    gameStatus.textContent = 'Check! ' + gameStatus.textContent;
                    gameStatus.style.color = '#ff6b6b';
                } else {
                    gameStatus.style.color = '#f0f0f0';
                }
            }
            
            // Update move history display
            function updateMoveHistory() {
                moveList.innerHTML = '';
                
                // Group moves by turn
                for (let i = 0; i < moveHistory.length; i += 2) {
                    const moveEntry = document.createElement('div');
                    moveEntry.className = 'move-entry';
                    
                    const whiteMove = moveHistory[i];
                    const blackMove = moveHistory[i + 1];
                    
                    const turnNumber = Math.floor(i / 2) + 1;
                    moveEntry.innerHTML = `
                        <span>${turnNumber}. ${whiteMove?.notation || ''}</span>
                        <span>${blackMove?.notation || ''}</span>
                    `;
                    
                    moveList.appendChild(moveEntry);
                }
                
                // Scroll to bottom
                moveList.scrollTop = moveList.scrollHeight;
            }
            
            // User authentication functions
            function checkUserStatus() {
                const savedUser = localStorage.getItem('chess_current_user');
                if (savedUser) {
                    currentUser = JSON.parse(savedUser);
                    displayUsername.textContent = currentUser.username;
                    userInfo.style.display = 'flex';
                    loginButtons.style.display = 'none';
                    
                    // Update player names
                    whitePlayer.textContent = currentUser.username + ' (White)';
                } else {
                    currentUser = null;
                    userInfo.style.display = 'none';
                    loginButtons.style.display = 'flex';
                    
                    // Update player names
                    whitePlayer.textContent = 'Guest (White)';
                }
            }
            
            function showLoginModal() {
                loginModal.style.display = 'flex';
                signupModal.style.display = 'none';
            }
            
            function showSignupModal() {
                signupModal.style.display = 'flex';
                loginModal.style.display = 'none';
            }
            
            function hideModals() {
                loginModal.style.display = 'none';
                signupModal.style.display = 'none';
            }
            
            function login(username, password) {
                // Clear errors
                document.querySelectorAll('.error-message').forEach(el => {
                    el.style.display = 'none';
                });
                
                // Validate input
                if (!username) {
                    document.getElementById('login-username-error').textContent = 'Username is required';
                    document.getElementById('login-username-error').style.display = 'block';
                    return false;
                }
                
                if (!password) {
                    document.getElementById('login-password-error').textContent = 'Password is required';
                    document.getElementById('login-password-error').style.display = 'block';
                    return false;
                }
                
                // Check if user exists
                if (!users[username]) {
                    document.getElementById('login-username-error').textContent = 'User not found';
                    document.getElementById('login-username-error').style.display = 'block';
                    return false;
                }
                
                // Check password
                if (users[username].password !== password) {
                    document.getElementById('login-password-error').textContent = 'Incorrect password';
                    document.getElementById('login-password-error').style.display = 'block';
                    return false;
                }
                
                // Login successful
                currentUser = users[username];
                localStorage.setItem('chess_current_user', JSON.stringify(currentUser));
                checkUserStatus();
                hideModals();
                
                // Clear form
                document.getElementById('login-form').reset();
                return true;
            }
            
            function signup(username, email, password, confirmPassword) {
                // Clear errors
                document.querySelectorAll('.error-message').forEach(el => {
                    el.style.display = 'none';
                });
                
                // Validate input
                if (!username) {
                    document.getElementById('signup-username-error').textContent = 'Username is required';
                    document.getElementById('signup-username-error').style.display = 'block';
                    return false;
                }
                
                if (username.length < 3) {
                    document.getElementById('signup-username-error').textContent = 'Username must be at least 3 characters';
                    document.getElementById('signup-username-error').style.display = 'block';
                    return false;
                }
                
                if (!email) {
                    document.getElementById('signup-email-error').textContent = 'Email is required';
                    document.getElementById('signup-email-error').style.display = 'block';
                    return false;
                }
                
                if (!password) {
                    document.getElementById('signup-password-error').textContent = 'Password is required';
                    document.getElementById('signup-password-error').style.display = 'block';
                    return false;
                }
                
                if (password.length < 6) {
                    document.getElementById('signup-password-error').textContent = 'Password must be at least 6 characters';
                    document.getElementById('signup-password-error').style.display = 'block';
                    return false;
                }
                
                if (password !== confirmPassword) {
                    document.getElementById('signup-confirm-error').textContent = 'Passwords do not match';
                    document.getElementById('signup-confirm-error').style.display = 'block';
                    return false;
                }
                
                // Check if username already exists
                if (users[username]) {
                    document.getElementById('signup-username-error').textContent = 'Username already taken';
                    document.getElementById('signup-username-error').style.display = 'block';
                    return false;
                }
                
                // Create new user
                users[username] = {
                    username,
                    email,
                    password,
                    rating: 1500,
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    draws: 0
                };
                
                // Save users to localStorage
                localStorage.setItem('chess_users', JSON.stringify(users));
                
                // Auto login
                currentUser = users[username];
                localStorage.setItem('chess_current_user', JSON.stringify(currentUser));
                checkUserStatus();
                hideModals();
                
                // Clear form
                document.getElementById('signup-form').reset();
                return true;
            }
            
            function logout() {
                currentUser = null;
                localStorage.removeItem('chess_current_user');
                checkUserStatus();
            }
            
            // Update available games list
            function updateAvailableGames() {
                // Simulated game data
                availableGames = [
                    { id: 1, white: 'Player1', black: 'Player2', timeControl: '5+0', status: 'active' },
                    { id: 2, white: 'ChessMaster', black: 'Waiting...', timeControl: '10+0', status: 'waiting' },
                    { id: 3, white: 'GrandMaster', black: 'ProPlayer', timeControl: '3+2', status: 'active' }
                ];
                
                const gameList = document.getElementById('game-list');
                gameList.innerHTML = '';
                
                availableGames.forEach(game => {
                    const gameItem = document.createElement('div');
                    gameItem.className = 'game-item';
                    gameItem.innerHTML = `
                        <div class="game-item-header">
                            <span>${game.white} vs ${game.black}</span>
                            <span>${game.timeControl}</span>
                        </div>
                        <div class="game-item-players">Click to join</div>
                    `;
                    
                    gameItem.addEventListener('click', () => {
                        if (game.status === 'waiting') {
                            joinGame(game.id);
                        } else {
                            spectateGame(game.id);
                        }
                    });
                    
                    gameList.appendChild(gameItem);
                });
            }
            
            function joinGame(gameId) {
                alert(`Joining game ${gameId}. In a real implementation, this would connect you to the game.`);
                // Here you would typically connect to a game server
            }
            
            function spectateGame(gameId) {
                alert(`Spectating game ${gameId}. In a real implementation, this would show you the game.`);
            }
            
            // Set up event listeners
            function setupEventListeners() {
                // Square click events
                document.querySelectorAll('.square').forEach(square => {
                    square.addEventListener('click', function() {
                        const row = parseInt(this.dataset.row);
                        const col = parseInt(this.dataset.col);
                        handleSquareClick(row, col);
                    });
                });
                
                // Game control buttons
                newGameBtn.addEventListener('click', function() {
                    setupPieces();
                    selectedPiece = null;
                    validMoves = [];
                    currentPlayer = 'white';
                    gameOver = false;
                    renderBoard();
                    updateGameStatus();
                });
                
                undoBtn.addEventListener('click', function() {
                    if (moveHistory.length > 0) {
                        // Simple undo - just reset the game
                        setupPieces();
                        selectedPiece = null;
                        validMoves = [];
                        currentPlayer = 'white';
                        gameOver = false;
                        renderBoard();
                        updateGameStatus();
                    }
                });
                
                resignBtn.addEventListener('click', function() {
                    if (!gameOver) {
                        gameOver = true;
                        const winner = currentPlayer === 'white' ? 'Black' : 'White';
                        gameStatus.textContent = `Resignation! ${winner} wins!`;
                    }
                });
                
                // Game finder buttons
                playComputerBtn.addEventListener('click', function() {
                    gameMode = 'computer';
                    blackPlayer.textContent = 'Computer (Black)';
                    setupPieces();
                    selectedPiece = null;
                    validMoves = [];
                    currentPlayer = 'white';
                    gameOver = false;
                    renderBoard();
                    updateGameStatus();
                });
                
                findPlayerBtn.addEventListener('click', function() {
                    if (!currentUser) {
                        alert('Please login to play against other players');
                        showLoginModal();
                        return;
                    }
                    
                    gameMode = 'player';
                    blackPlayer.textContent = 'Searching for opponent...';
                    
                    // Simulate finding a player
                    setTimeout(() => {
                        blackPlayer.textContent = 'Opponent (Black)';
                        setupPieces();
                        selectedPiece = null;
                        validMoves = [];
                        currentPlayer = 'white';
                        gameOver = false;
                        renderBoard();
                        updateGameStatus();
                    }, 2000);
                });
                
                // Time control buttons
                timeBtns.forEach(btn => {
                    btn.addEventListener('click', function() {
                        timeBtns.forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        const minutes = parseInt(this.dataset.time);
                        gameTime = minutes * 60;
                    });
                });
                
                // Auth event listeners
                loginBtn.addEventListener('click', showLoginModal);
                signupBtn.addEventListener('click', showSignupModal);
                logoutBtn.addEventListener('click', logout);
                
                closeLogin.addEventListener('click', hideModals);
                closeSignup.addEventListener('click', hideModals);
                
                switchToSignup.addEventListener('click', showSignupModal);
                switchToLogin.addEventListener('click', showLoginModal);
                
                // Login form submission
                loginForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const username = document.getElementById('login-username').value;
                    const password = document.getElementById('login-password').value;
                    login(username, password);
                });
                
                // Signup form submission
                signupForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const username = document.getElementById('signup-username').value;
                    const email = document.getElementById('signup-email').value;
                    const password = document.getElementById('signup-password').value;
                    const confirmPassword = document.getElementById('signup-confirm-password').value;
                    signup(username, email, password, confirmPassword);
                });
                
                // Close modals when clicking outside
                window.addEventListener('click', function(e) {
                    if (e.target === loginModal) hideModals();
                    if (e.target === signupModal) hideModals();
                });
            }
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>
